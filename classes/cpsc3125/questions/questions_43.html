<li> On a keyboard, an interrupt is generated
	<ol class="answer_list">
	<li> only when a key is pressed.
	<li> only when a key is released.
	<li> every N milliseconds (as configured by the device driver) for as
		long as the key is held down.
	<li> once when the key is pressed, and once when it is released.
	<li> None of the above
	</ol>
</li><br/>
<li> A device driver for supporting keyboards that passes along every typed
	character (including backspacing) supports input in
	<ol class="answer_list">
	<li> canonical mode.
	<li> non-canonical mode.
	<li> half-duplex mode.
	<li> full-duplex mode.
	<li> None of the above
	</ol>
</li><br/>
<li> Which device driver mode for supporting keyboards works
	<strong>best</strong> for full screen editors (e.g., vi, emacs)?
	<ol class="answer_list">
	<li> canonical mode.
	<li> non-canonical mode.
	<li> half-duplex mode.
	<li> full-duplex mode.
	<li> None of the above
	</ol>
</li><br/>
<li> Which device driver mode for supporting keyboards works
	<strong>best</strong> for command line programs (e.g., shell)?
	<ol class="answer_list">
	<li> canonical mode.
	<li> non-canonical mode.
	<li> half-duplex mode.
	<li> full-duplex mode.
	<li> None of the above
	</ol>
</li><br/>
<li> The device driver approach for supporting keyboards that is character
	oriented is also called
	<ol class="answer_list">
	<li> canonical mode.
	<li> non-canonical mode.
	<li> half-duplex mode.
	<li> full-duplex mode.
	<li> raw mode.
	<li> cooked mode.
	<li> None of the above
	</ol>
</li><br/>
<li> The device driver approach for supporting keyboards that is line
	oriented is also called
	<ol class="answer_list">
	<li> canonical mode.
	<li> non-canonical mode.
	<li> half-duplex mode.
	<li> full-duplex mode.
	<li> raw mode.
	<li> cooked mode.
	<li> None of the above
	</ol>
</li><br/>
<li> For a mouse, an interrupt is generated
	<ol class="answer_list">
	<li> each time a button is pressed.
	<li> each time a button is released.
	<li> every 40 milliseconds (as configured by the device driver)
		regardless of what the user does with the mouse.
	<li> whenever the mouse has traveled a predetermined minimum distance.
	<li> None of the above
	</ol>
</li><br/>
<li> Mouse input, unlike keyboard input, 
	<ol class="answer_list">
	<li> only supports raw mode.
	<li> only supports cooked mode.
	<li> supports both raw and cooked modes.
	<li> doesn't support either raw or cooked modes, but uses echoing
		instead. 
	<li> None of the above
	</ol>
</li><br/>
<li> While touch screens operate much the same way that mice do, a notable
	difference is that
	<ol class="answer_list">
	<li> mice have button(s) that can be pressed and released, whereas
		touch screens do <strong>not</strong> have a comparable
		capability.
	<li> mice suffer fromm the ghosting problem, whereas touch screens
		do <strong>not</strong>.
	<li> touch screens supply the absolute position of a touch instead of
		the relative position which mice provide.
	<li> touch screens can support multitouch whereas mice do
		<strong>not</strong> have a comparable capability.
	<li> None of the above
	</ol>
</li><br/>
<li> In order to support multitouch, touch screens should provide a continuous
	stream of position data 
	<ol class="answer_list">
	<li> in order to create the relative position data that it needs. 
	<li> to avoid the ghosting problem (i.e., the touch position is
		ambiguous).
	<li> otherwise data reported at discrete time increments will be
		understood as multiple separate touches (e.g., mouse clicks).
	<li> to prevent echoing, in which a single touch point may look like
		multiple touches.
	<li> None of the above
	</ol>
</li><br/>
<li> Text (or terminal) windows use
	<ol class="answer_list">
	<li> special character sequences to position the cursor and perform
		text insertion and deletion.
	<li> mixed sized text and different font styles to support document
		processing (e.g., Microsoft Word).
	<li> terminal capability (termcap) libraries to provide device
		independent support.
	<li> the raw scan codes from the keyboard, which is why they were
		commonly used on early computers.
	<li> None of the above
	</ol>
</li><br/>
<li> X11 is a windowing system
	<ol class="answer_list">
	<li> commonly used by Linux based systems.
	<li> allows programs to be run on one computer, with the display and
		interaction occurring on another computer.
	<li> uses a client-server model to separate the program's GUI operation
		from the rest of the program.
	<li> that is event driven. 
	<li> None of the above
	</ol>
</li><br/>
<li> Microsoft Windows and X11 differ in that
	<ol class="answer_list">
	<li> X11 is implemented as part of the OS kernel.
	<li> X11 user programs <strong>must</strong> explicitly coordinate the
		communication between the client and server components.
	<li> Microsoft Windows is portable and relatively easy to maintain.
	<li> Microsoft Windows combines the windowing and GUI elements together
		within the OS.
	<li> None of the above
	</ol>
</li><br/>
<li> Graphical User Interfaces (GUIs) are characterized by their use of
	<ol class="answer_list">
	<li> Windows
	<li> Icons
	<li> Menus
	<li> Pointing devices
	<li> None of the above
	</ol>
</li><br/>
<li> Unlike text windows, graphical user interfaces (GUIs)
	<ol class="answer_list">
	<li> are slower since they <strong>must</strong> use Programmed I/O.
	<li> require a graphics processing unit (GPU) be part of the hardware.
	<li> leverage a common graphical API (e.g., OpenGL) to make the
		software more portable.
	<li> <strong>must</strong> use the integerated graphics provided by
		the computer hardware (on the motherboard).
	<li> None of the above
	</ol>
</li><br/>
