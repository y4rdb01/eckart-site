<li> Every class in Java either directly or indirectly
	<ol class="answer_list">
	<li> Implements the "ToString", "Equals", and "Finalize" interfaces.
	<li> Implements the "Clone" and "HashCode" interfaces.
	<li> Extends the "Object" class.
	<li> Extends the "Runnable" class.
	<li> None of the above
	</ol>
</li><br/>
<li> In Java, accessing an overridden method in the superclass from the
	subclass is
	<ol class="answer_list">
	<li> Not possible.
	<li> Done using "super()", letting Java determine the overridden
		method and parameters automatically.
	<li> Done using "super(parameters)", letting Java determine the
		overridden method automatically but allowing the programming
		to specify the intended "parameters".
	<li> Done using "super.method(parameters)", where "method" and
		"parameters" are provided by the programmer and are specific
		to the overridden method to use.
	<li> None of the above
	</ol>
</li><br/>
<li> In Java, accessing an overridden field in the superclass from the
	subclass is
	<ol class="answer_list">
	<li> Not possible.
	<li> Done using "super.field".
	<li> Done using "field.super".
	<li> Done using "super(field)".
	<li> None of the above
	</ol>
</li><br/>
<li> Java guarantees that a constructor is called for every new object creation,
	but any constructors in the superclass
	<ol class="answer_list">
	<li> Are called at least once.
	<li> Are called at most once.
	<li> Are called exactly once.
	<li> <strong>Must</strong> be explicitly called by the programmer.
	<li> None of the above
	</ol>
</li><br/>
<li> In Java, to prevent a method from being overridden in a subclass,
	declare the superclass method as
	<ol class="answer_list">
	<li> Abstract
	<li> Const
	<li> Final
	<li> Virtual
	<li> None of the above
	</ol>
</li><br/>
<li> Abstract methods in Java
	<ol class="answer_list">
	<li> Are declared with an implementation "= 0".
	<li> <strong>Must</strong> be overridden in non-abstract subclasses.
	<li> May only appear in abstract classes.
	<li> Can <strong>never</strong> be declared as final.
	<li> None of the above
	</ol>
</li><br/>
<li> In Java, you cannot create an instance of a class that is declared as 
	<ol class="answer_list">
	<li> Abstract
	<li> Final
	<li> Static
	<li> Virtual
	<li> None of the above
	</ol>
</li><br/>
<li> In Java, you cannot define a subclass of a class that is declared as 
	<ol class="answer_list">
	<li> Abstract
	<li> Final
	<li> Static
	<li> Virtual
	<li> None of the above
	</ol>
</li><br/>
<li> Java's ability to implement multiple interfaces, rather than allowing
	multiple inheritance, to support multiple compatible polymorphic
	types for a class, avoids the
	<ol class="answer_list">
	<li> Linearization problem.
	<li> Diamond problem.
	<li> Array Covariance problem.
	<li> Substitutivity problem.
	<li> None of the above
	</ol>
</li><br/>
<li> In Java, interfaces rather than classes are often considered the
	<strong>best</strong> way in which to describe the types of variables
	and passed parameters because
	<ol class="answer_list">
	<li> Classes can implement only a single interface.
	<li> Classes can extend only a single class.
	<li> Interfaces can be implemented by many classes.
	<li> Interfaces can extend only a single interface.
	<li> None of the above
	</ol>
</li><br/>
