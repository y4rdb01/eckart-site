<li> Concurrency occurs when multiple
	<ol class="answer_list">
	<li> Sequences of actions are accomplished (seemingly)
		"simultaneously".
	<li> Programs are trying to access the same file.
	<li> People are using the same computer.
	<li> Computers are being used by the same person.
	<li> None of the above
	</ol>
</li><br/>
<li> Multiprogramming
	<ol class="answer_list">
	<li> Is the same as Multiprocessing.
	<li> Occurs when different processes share the same processor by
		interleaving their actions in an unpredictable order.
	<li> Happens when multiple processes are trying to use the same file.
	<li> Occurs when different processes execute on different processors
		at the same time.
	<li> None of the above
	</ol>
</li><br/>
<li> Multiprocessing
	<ol class="answer_list">
	<li> Is the same as Multiprogramming.
	<li> Occurs when different processes share the same processor by
		interleaving their actions in an unpredictable order.
	<li> Happens when multiple processes are trying to use the same file.
	<li> Occurs when different processes execute on different processors
		at the same time.
	<li> None of the above
	</ol>
</li><br/>
<li> When using multiprogramming/multiprocessing the ordering of actions
	between different executions of the program
	<ol class="answer_list">
	<li> are <strong>always</strong> exactly the same.
	<li> are <strong>never</strong> exactly the same.
	<li> are sometimes the same.
	<li> are predetermined by the compiler.
	<li> None of the above
	</ol>
</li><br/>
<li> Debugging multiprogramming/multiprocessing systems is difficult because
	<ol class="answer_list">
	<li> It's much more difficult to know that a problem has occurred.
	<li> The execution order that causes a bug may rarely happen.
	<li> If real-time data is used, the circumstances that cause the
		error may be nearly impossible to recreate.
	<li> The "randomness" of the error makes it difficult to know whether
		or not a bug was actually fixed.
	<li> None of the above
	</ol>
</li><br/>
<li> Inter-process communication can be accomplished by
	<ol class="answer_list">
	<li> Message passing.
	<li> Atomic reads/writes of data.
	<li> Spin locking.
	<li> Shared memory.
	<li> None of the above
	</ol>
</li><br/>
<li> Declaring a Java variable to be "volatile" ensures that
	<ol class="answer_list">
	<li> It will <strong>not</strong> be cached by threads.
	<li> Only the single threaded portion of a process can access it.
	<li> <strong>All</strong> reads and writes of the variable occur
		from main/shared memory.
	<li> The variable is allocated from heap storage.
	<li> None of the above
	</ol>
</li><br/>
<li> If messages sent between communicating processes are unbuffered
	<ol class="answer_list">
	<li> The message ordering <strong>must</strong> be preserved.
	<li> Then messages can be lost if the receiving process isn't ready
		for them.
	<li> The system is invulnerable to a buffer overflow attack.
	<li> Then the communications should also be asynchronous.
	<li> None of the above
	</ol>
</li><br/>
<li> Synchronous messaging between communicating processes
	<ol class="answer_list">
	<li> Is redundant since asynchronous messaging subsumes it.
	<li> Can result in lost messages if the receiving process isn't ready
		for them.
	<li> Requires that <strong>both</strong> the message sender and
		receiver are ready at the same time.
	<li> Improves the efficiency of communication, making the processes
		run much faster.
	<li> None of the above
	</ol>
</li><br/>
<li> Preserving message order between communicating processes
	<ol class="answer_list">
	<li> Requires that messages also be unbuffered.
	<li> Requires the communicating processes also be synchronized.
	<li> Is necessary for <strong>all</strong>
		multiprogramming/multiprocessing systems
		to ensure proper operation.
	<li> Is only important for some types of applications (e.g., video
		streaming) but <strong>not</strong> others
		(e.g., http requests).
	<li> None of the above
	</ol>
</li><br/>
<li> Atomicity is the property that an action
	<ol class="answer_list">
	<li> Corresponds to a single statement in the source program.
	<li> Corresponds to a single instruction in the object code
		generated by the compiler.
	<li> <strong>Must</strong> happen in its entirety without interruption.
	<li> Is using a single "quanta" of information (e.g., a primitive
		type value).
	<li> None of the above
	</ol>
</li><br/>
<li> A <em>critical section</em> is that part of the program code in a
	multiprogramming/multiprocessing system
	<ol class="answer_list">
	<li> Essential for the proper operation of the program.
	<li> Uniquely capable of accessing multiple variables.
	<li> Which accesses shared resources.
	<li> That should only be accessed by one thread at a time.
	<li> None of the above
	</ol>
</li><br/>
<li> Processes that are prevented from being in the same <em>critical
	section</em> at the same time are exhibiting
	<ol class="answer_list">
	<li> Synchronicity
	<li> Shared Execution
	<li> Iterative Interleavement
	<li> Mutual Exclusion
	<li> None of the above
	</ol>
</li><br/>
<li> Processes sharing a <em>critical section</em> should exhibit "bounded
	waiting" so that
	<ol class="answer_list">
	<li> Every process waits a fixed maximum amount
		of time to enter the <em>critical section</em>.
	<li> No process waits indefinitely to enter the <em>critical
		section</em>.
	<li> Waiting processes may enter the <em>critical
		section</em> if no other process is using it.
	<li> <strong>All</strong> processes take turns using the
		<em>critical section</em>.
	<li> None of the above
	</ol>
</li><br/>
<li> Processes sharing a <em>critical section</em> should exhibit "progress",
	so that
	<ol class="answer_list">
	<li> Every process waits no longer than a fixed maximum amount
		of time to enter the <em>critical section</em>.
	<li> No process waits indefinitely to enter the <em>critical
		section</em>.
	<li> Waiting processes may enter the <em>critical
		section</em> if no other process is using it.
	<li> <strong>All</strong> processes take turns using the
		<em>critical section</em>.
	<li> None of the above
	</ol>
</li><br/>
<li> Deadlock occurs only when which of the following conditions are true?
	<ol class="answer_list">
	<li> At least one resource needed by the processes cannot be shared.
	<li> Each process holds resources until it is finished.
	<li> Resources cannot be taken away from processes currently holding
		them.
	<li> A cycle exists in the process resource dependency graph.
	<li> None of the above
	</ol>
</li><br/>
