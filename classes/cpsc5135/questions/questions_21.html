<li> Thrown exceptions in C++
	<ol class="answer_list">
	<li> <strong>Must</strong> extend a common exception class as in Java.
	<li> <strong>Must</strong> be a class instance.
	<li> Can be any value (either class instance or primitive type value).
	<li> <strong>Must</strong> be a primitive type value.
	<li> None of the above
	</ol>
</li><br/>
<li> The "static" declaration in C++ is similar to Java's
	<ol class="answer_list">
	<li> virtual
	<li> final
	<li> static
	<li> abstract
	<li> None of the above
	</ol>
</li><br/>
<li> Templates in C++
	<ol class="answer_list">
	<li> Work exactly like generics in Java.
	<li> Can be instantiated with primitive types.
	<li> Can be anonymously instantiated.
	<li> <strong>Must</strong> be instantiated with a new class/type
		name (e.g., like Ada).
	<li> None of the above
	</ol>
</li><br/>
<li> C++ thrown exceptions are
	<ol class="answer_list">
	<li> Caught and handled by try-catch blocks similar to those in Java.
	<li> Handled by the special "finalize" member function defined within
		a class.
	<li> <strong>Must</strong> be caught and handled in the "main" function.
	<li> Ignored if <strong>not</strong> caught and handled within the
		code block they were first thrown from.
	<li> None of the above
	</ol>
</li><br/>
<li> While the number and types of parameters of overloaded functions
	<strong>must</strong> match, C++
	<ol class="answer_list">
	<li> Requires that their semantics also match.
	<li> Allows the semantics to be very different.
	<li> Allows different semantics, but only within specific constraints.
	<li> Also requires that they throw the same exceptions.
	<li> None of the above
	</ol>
</li><br/>
<li> Recursive class definitions in C++
	<ol class="answer_list">
	<li> Are of unknown size until an instance is created via the
		"new" operator.
	<li> <strong>Must</strong> use pointers to the nested occurrences.
	<li> Cannot use inline functions because they would be expanded an
		infinite number of times.
	<li> <strong>Must</strong> be declared as private.
	<li> None of the above
	</ol>
</li><br/>
<li> Nested class definitions in C++
	<ol class="answer_list">
	<li> Are <strong>not</strong> allowed.
	<li> Can only be created as heap allocations.
	<li> Can only be created as run-time stack allocations.
	<li> <strong>Must</strong> be declared as private.
	<li> None of the above
	</ol>
</li><br/>
<li> The "new" operator in C++
	<ol class="answer_list">
	<li> Is similar to the "new" operator in Java.
	<li> Allocates space on the run-time stack.
	<li> Allocates space from the heap.
	<li> Returns the memory address of the allocated memory.
	<li> None of the above
	</ol>
</li><br/>
<li> C++ has the "delete" operation in order to
	<ol class="answer_list">
	<li> Remove class definitions that are no longer needed.
	<li> Allow programmers to suggest heap storage to garbage collect,
		but doesn't actually free the space itself.
	<li> Do nothing since C++ has garbage collection just like Java.
	<li> Remove the top entry from the run-time stack.
	<li> None of the above
	</ol>
</li><br/>
<li> Which of the following languages support garbage collection of dynamic
	memory allocations?
	<ol class="answer_list">
	<li> Lisp
	<li> Java
	<li> C++
	<li> Prolog
	<li> None of the above
	</ol>
</li><br/>
<li> The "typename" keyword in C++ can be used to
	<ol class="answer_list">
	<li> Disambiguate situations in which a qualified dependent type
		could also be interpreted as a statement/expression.
	<li> Declare a new type definition.
	<li> Indicate the return type of a method/function.
	<li> Indicate a template parameter, as a relacement for "class".
	<li> None of the above
	</ol>
</li><br/>
<li> What did C.A.R. Hoare describe as his billion dollar mistake?
	<ol class="answer_list">
	<li> The design and creation of Lisp.
	<li> The introduction of garbage collection.
	<li> The design and creation of C++.
	<li> The introduction of null (pointer) references.
	<li> None of the above
	</ol>
</li><br/>
<li> Why did C.A.R. Hoare include null (pointer) references into the design
	of Algol W in 1965?
	<ol class="answer_list">
	<li> It was easy to implement.
	<li> To ensure that <strong>all</strong> uses of references were
		absolutely safe.
	<li> It was the feature most requested by developers.
	<li> To enable polymorphism.
	<li> None of the above
	</ol>
</li><br/>
