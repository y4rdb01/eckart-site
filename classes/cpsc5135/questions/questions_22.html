<li> Having two comment types like C++'s and Java's // and /* ... */ is
	<ol class="answer_list">
	<li> Completely unnecessary.
	<li> Error prone.
	<li> Useful if // is generally used and /* ... */ is used for
		commenting out larger blocks of code (e.g., debugging).
	<li> Essential for supporting proper documentation.
	<li> None of the above
	</ol>
</li><br/>
<li> C++ destructors are called
	<ol class="answer_list">
	<li> When objects on the run-time stack go out of scope.
	<li> When heap objects are deallocated.
	<li> Only by explicit programmer coded calls.
	<li> Never, C++ doesn't have destructors (only finalize methods).
	<li> None of the above
	</ol>
</li><br/>
<li> Unlike Java, C++ method implementations
	<ol class="answer_list">
	<li> <strong>Must</strong> be given in the class declaration.
	<li> May occur inside or outside the class declaration.
	<li> <strong>Must all</strong> appear in the same file as the class
		declaration.
	<li> May appear in separate files from the class declaration.
	<li> None of the above
	</ol>
</li><br/>
<li> A "pure virtual" function in C++ (e.g., "virtual int doit() = 0")
	<ol class="answer_list">
	<li> Cannot be overridden in a subclass.
	<li> Requires its class to also be "virtual".
	<li> Corresponds to "abstract" methods in Java.
	<li> <strong>Must</strong> be overridden in a non-virtual subclass.
	<li> None of the above
	</ol>
</li><br/>
<li> In C++, name clashes occur when two member names
	<ol class="answer_list">
	<li> Declared within the same class are the same.
	<li> Inherited from different classes are the same.
	<li> Are names of overloaded functions.
	<li> Are names of overloaded exceptions.
	<li> None of the above
	</ol>
</li><br/>
<li> C++ uses which of the following ways to resolve name clashes?
	<ol class="answer_list">
	<li> Disallow
	<li> Implicit resolution
	<li> Explicit resolution
	<li> Inherited resolution
	<li> None of the above
	</ol>
</li><br/>
<li> Multiple inheritance in C++ means that a new class definition can extend
	<ol class="answer_list">
	<li> the same class multiple times (getting additional copies
		of its instance and class variables).
	<li> multiple different classes, thus combining their
		capabilities within the new class.
	<li> a pre-existing class, and that other class definitions
		can also extend that same pre-existing class.
	<li> itself, as a way to create recursive data structures.
	<li> None of the above
	</ol>
</li><br/>
<li> The diamond problem refers to:
	<ol class="answer_list">
	<li> Java classes that <strong>both</strong> extend a class and
		implement an interface.
	<li> Prolog predicates that match two tails (e.g., "[ X | Y | Z]").
	<li> C++ classes that extend a single class.
	<li> Smalltalk methods that return objects <strong>not</strong>
		of the receiver's class.
	<li> None of the above
	</ol>
</li><br/>
<li> The diamond problem is a special kind of name clash that
	<ol class="answer_list">
	<li> Can occur in <strong>all</strong> object-oriented languages.
	<li> Can occur only in Java because it has <strong>both</strong>
		inheritance and interfaces.
	<li> Can occur in C++ because it allows multiple inheritance.
	<li> Is addressed in Java primarily through the implementation
		of (multiple) interfaces.
	<li> None of the above
	</ol>
</li><br/>
